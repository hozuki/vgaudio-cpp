#include <cassert>
#include <cmath>
#include <type_traits>

#include "../../../common/utilities/array_gen.h"
#include "../../../common/utilities/ArrayHelper.h"
#include "../../utilities/ArrayUnpacker.h"
#include "CriHcaTables.h"

using namespace std;
using namespace vgaudio::codecs::crihca;
using namespace vgaudio::utilities;
using namespace common_lib::utilities;

static uint8_t PackedTables[] = {
    0x01, 0x62, 0x07, 0x00, 0x00, 0x7C, 0xD0, 0x85, 0x71, 0x03, 0x41, 0x0C, 0x85, 0x61, 0xC1, 0xB2,
    0xD9, 0xED, 0xA4, 0xC7, 0xD4, 0x6B, 0x3C, 0xD0, 0x3B, 0x52, 0xF0, 0x1F, 0xD2, 0x77, 0xA8, 0x59,
    0xA2, 0x46, 0x2C, 0xE7, 0x42, 0x67, 0xFA, 0x23, 0x25, 0xF1, 0xCC, 0x42, 0x9C, 0x1C, 0xA3, 0x92,
    0x84, 0xB4, 0xF0, 0x94, 0x82, 0x10, 0x6B, 0x3C, 0xCE, 0x3C, 0xEC, 0xE0, 0xB6, 0x3F, 0xCE, 0xAC,
    0x78, 0xBF, 0xE0, 0x02, 0x88, 0xF7, 0x71, 0x41, 0x7E, 0x5F, 0x83, 0x59, 0xC4, 0x5B, 0x90, 0xEA,
    0x66, 0x45, 0x8B, 0xD5, 0xA7, 0x21, 0xB8, 0x19, 0xB9, 0x19, 0xF9, 0x19, 0x66, 0x5B, 0x42, 0xA6,
    0xCB, 0x31, 0xE5, 0x52, 0xDB, 0x6E, 0x4F, 0xFF, 0x1E, 0x91, 0xB0, 0x78, 0xAA, 0xED, 0xE7, 0xA8,
    0x2A, 0x6E, 0xBF, 0xB0, 0x6C, 0x33, 0x33, 0x84, 0x65, 0x21, 0xD0, 0x32, 0x5A, 0x46, 0x64, 0x44,
    0xD7, 0xCB, 0xEF, 0x6B, 0x70, 0xFF, 0xCD, 0xDC, 0xF7, 0xD2, 0x39, 0x8F, 0xD2, 0xF7, 0xB7, 0xFB,
    0xD2, 0x75, 0xAA, 0xEF, 0x77, 0x78, 0x39, 0x8F, 0x8A, 0xCF, 0xD9, 0xB3, 0xD2, 0x63, 0xB4, 0x53,
    0xBE, 0x57, 0x3B, 0x8D, 0x42, 0xC4, 0x84, 0x78, 0xFB, 0x2A, 0xF1, 0x64, 0x0C, 0x66, 0xD0, 0x3D,
    0xE2, 0x5D, 0x98, 0xAA, 0x8D, 0x81, 0x58, 0xB3, 0x46, 0xA6, 0x0F, 0x3A, 0x1D, 0xD1, 0x01, 0xED,
    0xD1, 0x0E, 0xB5, 0xA9, 0x8A, 0x0A, 0xCA, 0x29, 0xC5, 0xE9, 0xB0, 0x64, 0x8C, 0x13, 0xD3, 0xA7,
    0x0C, 0x84, 0xC1, 0x83, 0x01, 0x42, 0x01, 0x14, 0x00, 0xC0, 0xC1, 0xFA, 0xB6, 0x6D, 0x8F, 0xD1,
    0xF8, 0x3D, 0x65, 0xDD, 0x9D, 0xF7, 0xAE, 0xCC, 0x92, 0x38, 0x0C, 0x02, 0xDF, 0xF3, 0x5C, 0xD7,
    0x75, 0x80, 0x4D, 0x2C, 0x61, 0xDE, 0x18, 0x57, 0xFA, 0x13, 0x8D, 0xA8, 0x4C, 0x11, 0xA7, 0x3F,
    0x14, 0xA1, 0x0A, 0x8D, 0xE9, 0x9F, 0x18, 0x9F, 0x98, 0x3F, 0x59, 0x1F, 0xD9, 0xAF, 0x9C, 0x27,
    0xEE, 0x03, 0xEF, 0xC6, 0xBF, 0x09, 0x44, 0x28, 0x22, 0x11, 0xB3, 0x84, 0xA4, 0x24, 0x23, 0x39,
    0x29, 0x50, 0x89, 0x2A, 0x54, 0x83, 0x06, 0xB5, 0xA0, 0x03, 0x3D, 0x1A, 0x86, 0x61, 0x04, 0x13,
    0x98, 0xC1, 0xB2, 0x2C, 0x2B, 0xD8, 0xB6, 0x6D, 0xDF, 0xF7, 0xE3, 0x38, 0x2E, 0x0C, 0xC1, 0x83,
    0x01, 0xC0, 0x30, 0x00, 0x00, 0xB0, 0x57, 0x6B, 0xDB, 0xBE, 0x7D, 0x4B, 0xE0, 0x0F, 0x21, 0x84,
    0x31, 0x26, 0x84, 0x50, 0xCA, 0x18, 0xE3, 0x9C, 0x0B, 0x21, 0xA4, 0x54, 0x4A, 0x69, 0xAD, 0x8D,
    0xB1, 0xD6, 0x3A, 0xE7, 0x7D, 0x08, 0x21, 0xC6, 0x94, 0x72, 0xCE, 0xA5, 0xD4, 0xDA, 0x5A, 0xEF,
    0x63, 0x8C, 0x39, 0xD7, 0xDA, 0xFB, 0x9C, 0x7B, 0xDF, 0xFB, 0x08, 0x82, 0x07, 0x03, 0x80, 0x61,
    0x00, 0x00, 0x60, 0x9F, 0xAF, 0xB6, 0xED, 0x5F, 0x97, 0x00, 0x00, 0x21, 0x42, 0x98, 0x10, 0x4A,
    0x19, 0xE3, 0x5C, 0x48, 0xA9, 0x94, 0xD6, 0xC6, 0x5A, 0xE7, 0x7C, 0x08, 0x31, 0xA6, 0x9C, 0x4B,
    0xAD, 0xAD, 0xF5, 0x31, 0xE6, 0x5A, 0xFB, 0x9C, 0xFB, 0xDE, 0x0F, 0xD5, 0x00, 0x2A, 0xFF, 0x9E,
    0x9F, 0xA0, 0xA0, 0xA1, 0xA2, 0xA2, 0xA3, 0xA4, 0xA5, 0xA5, 0xA6, 0xA7, 0xA7, 0xA8, 0xA9, 0xAA,
    0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAE, 0xAF, 0xB0, 0xB1, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB6,
    0xB7, 0xB8, 0xB9, 0xBA, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC1, 0xC2, 0xC3, 0xC4,
    0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3,
    0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3,
    0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4,
    0xF5, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0x07, 0xA1, 0x09, 0x80, 0x00, 0xF0, 0x04, 0x35,
    0x3A, 0xB8, 0x83, 0x01, 0x3B, 0x38, 0xC5, 0x70, 0x3B, 0x68, 0x92, 0xBB, 0x3B, 0x09, 0xA8, 0x04,
    0x3C, 0x00, 0x82, 0x30, 0x3C, 0x4C, 0x28, 0x61, 0x3C, 0x17, 0x3F, 0x8B, 0x3C, 0x92, 0x39, 0xA8,
    0x3C, 0xBD, 0x7F, 0xC7, 0x3C, 0x10, 0x11, 0xE9, 0x3C, 0xCD, 0x77, 0x06, 0x3D, 0xC4, 0x8F, 0x19,
    0x3D, 0x5C, 0xD3, 0x2D, 0x3D, 0x43, 0x46, 0x43, 0x3D, 0xC1, 0xEC, 0x59, 0x3D, 0xA8, 0xCB, 0x71,
    0x3D, 0x1E, 0x74, 0x85, 0x3D, 0x13, 0xA4, 0x92, 0x3D, 0xB4, 0x78, 0xA0, 0x3D, 0x22, 0xF5, 0xAE,
    0x3D, 0x9E, 0x1C, 0xBE, 0x3D, 0x7B, 0xF2, 0xCD, 0x3D, 0x1D, 0x7A, 0xDE, 0x3D, 0xED, 0xB6, 0xEF,
    0x3D, 0x2B, 0xD6, 0x00, 0x0D, 0x83, 0x03, 0xB4, 0x10, 0x01, 0x10, 0x00, 0xB3, 0x6D, 0xDB, 0xB6,
    0xDB, 0xC9, 0xB6, 0x6D, 0xDB, 0xBC, 0xBB, 0xCD, 0xB6, 0x6D, 0xDB, 0x7A, 0xCA, 0xD6, 0xB7, 0x6D,
    0xDB, 0x1E, 0x88, 0x6B, 0x8B, 0x22, 0xD2, 0x24, 0xA8, 0xAC, 0x3C, 0xCD, 0x55, 0x43, 0x62, 0x8D,
    0x46, 0x32, 0x76, 0x6A, 0x5B, 0xA9, 0x7D, 0x5D, 0x64, 0xED, 0xF0, 0x41, 0xC2, 0xEC, 0x71, 0xD2,
    0xD1, 0x6B, 0x96, 0xD8, 0x7C, 0x5A, 0x2E, 0x9D, 0x4A, 0x9B, 0x72, 0x6D, 0xF6, 0x4E, 0x79, 0xBD,
    0xEA, 0x80, 0xCC, 0x7C, 0x79, 0x5C, 0xA2, 0x9A, 0x9C, 0x97, 0xE5, 0xB6, 0xD7, 0xE4, 0xFE, 0xBD,
    0x7B, 0x52, 0xE7, 0xD9, 0x33, 0x29, 0x10, 0xF4, 0x4E, 0x3A, 0xF6, 0xFF, 0x24, 0xDD, 0xFF, 0xFF,
    0x92, 0x7E, 0x6A, 0x2F, 0x8D, 0x46, 0x7A, 0xC8, 0x94, 0x5E, 0x81, 0x92, 0x35, 0x2C, 0x4A, 0x9C,
    0x56, 0x25, 0xCB, 0x5D, 0xFB, 0x5C, 0xFC, 0x5C, 0x97, 0x9F, 0xAE, 0xD5, 0x8B, 0x30, 0xE0, 0x4B,
    0x09, 0xEA, 0x2F, 0x29, 0x4B, 0x6C, 0x89, 0x4A, 0x7C, 0xBC, 0x57, 0x8D, 0x6B, 0xDD, 0x6A, 0x73,
    0xF3, 0x43, 0x7D, 0x82, 0x3A, 0x34, 0xE1, 0xCC, 0xD9, 0x16, 0xE4, 0x0F, 0x6A, 0xC3, 0xA5, 0x6A,
    0x1D, 0xC9, 0xEC, 0xD8, 0x95, 0xD8, 0x0E, 0xB0, 0xA5, 0x62, 0x6F, 0x02, 0x9D, 0xFA, 0x71, 0x63,
    0xDD, 0x20, 0x8C, 0xD8, 0xA1, 0x2C, 0x1F, 0x34, 0x92, 0x2F, 0xE6, 0x18, 0xF2, 0x1E, 0x18, 0x4F,
    0xE4, 0x9A, 0x49, 0xEC, 0xEE, 0x34, 0x95, 0x82, 0x4E, 0xD3, 0x71, 0x1D, 0x31, 0x8B, 0xB3, 0xB7,
    0xE6, 0x50, 0xC8, 0x65, 0x1E, 0x25, 0x42, 0x16, 0xF0, 0xD4, 0x69, 0x11, 0xA5, 0x6F, 0x2D, 0x61,
    0xD6, 0xD8, 0x65, 0x04, 0x05, 0x2E, 0x27, 0x6A, 0xF2, 0x4A, 0x6C, 0x5E, 0xAE, 0x22, 0x30, 0x61,
    0x35, 0x7B, 0xAB, 0xAF, 0xA5, 0x6C, 0x8B, 0x75, 0x38, 0x35, 0x5A, 0x4F, 0xAD, 0x92, 0x1B, 0x68,
    0xE7, 0xBB, 0x81, 0x21, 0xD7, 0x37, 0x72, 0x7A, 0xF4, 0x26, 0x3A, 0xC7, 0x6F, 0x62, 0xC0, 0xAE,
    0xCD, 0xFC, 0x2D, 0x62, 0xF0, 0x7D, 0x9B, 0x41, 0x83, 0x28, 0x83, 0x5F, 0x23, 0x4C, 0x0E, 0xDD,
    0x31, 0xE9, 0x98, 0x64, 0xB2, 0xAB, 0xBB, 0x45, 0x13, 0xC3, 0xE2, 0xF7, 0x73, 0x8B, 0x82, 0x01,
    0x16, 0x4B, 0x4A, 0x29, 0xDB, 0x3B, 0x28, 0x3F, 0xC7, 0x2B, 0xAF, 0xD6, 0xE4, 0x7C, 0x50, 0x69,
    0x71, 0x5D, 0xD9, 0xFC, 0x52, 0x49, 0xFC, 0xAC, 0x44, 0xD8, 0x28, 0x0F, 0xDD, 0x95, 0x8D, 0x01,
    0xCA, 0x91, 0x70, 0xA5, 0x45, 0xAC, 0xB2, 0x27, 0x51, 0xF9, 0x9F, 0xA2, 0xB4, 0x49, 0x57, 0x5C,
    0x33, 0x94, 0x88, 0x4C, 0xE5, 0x70, 0x96, 0xE2, 0x95, 0x73, 0x7A, 0xCE, 0xD9
};

static double DequantizerScalingFunction(int32_t x) {
    return std::sqrt(128) * std::pow(std::pow(2, 53.0 / 128), x - 63);
}

static int32_t ResolutionMaxValueFunction(int32_t x) {
    if (x < 8) {
        return x;
    } else {
        return (1 << (x - 4)) - 1;
    }
}

static double QuantizerInverseStepSizeFunction(int32_t x) {
    return ResolutionMaxValueFunction(x) + 0.5;
}

static double QuantizerStepSizeFunction(int32_t x) {
    return x == 0 ? 0 : (1 / QuantizerInverseStepSizeFunction(x));
}

static double ScaleConversionTableFunction(int32_t x) {
    return x > 1 && x < 127 ? std::pow(std::pow(2, 53.0 / 128), x - 64) : 0;
}

static double IntensityRatioFunction(int32_t x) {
    return (28 - x * 2) / 14.0;
}

static double IntensityRatioBoundsFunction(int32_t x) {
    return (27 - x * 2) / 14.0;
}

static double QuantizerDeadZoneFunction(int32_t i) {
    const int32_t steps = ResolutionMaxValueFunction(i) + 1;
    const double boundary = QuantizerStepSizeFunction(i) / 2;

    const int64_t tmp = *reinterpret_cast<const int64_t *>(&boundary) - steps;
    return *reinterpret_cast<const double *>(&tmp);
}

static inline void GenerateCriHcaGlobalTables() noexcept;

static struct _CriHcaGlobalTables {

    _CriHcaGlobalTables() noexcept {
        GenerateCriHcaGlobalTables();
    }

    ~_CriHcaGlobalTables() = default;

    narray_ptr<double, 64> dequantizerScalingTable;
    narray_ptr<double, 16> quantizerStepSize;
    narray_ptr<double, 16> quantizerDeadZone;
    narray_ptr<double, 64> quantizerScalingTable;
    narray_ptr<double, 16> quantizerInverseStepSize;
    narray_ptr<int32_t, 16> resolutionMaxValues;
    narray_ptr<double, 15> intensityRatioTable;
    narray_ptr<double, 14> intensityRatioBoundsTable;
    narray_ptr<double, 128> scaleConversionTable;

    array_ptr<uint8_t> defaultChannelMapping;
    jarray2_ptr<uint8_t> validChannelMappings;
    array_ptr<uint8_t> scaleToResolutionCurve;
    array_ptr<uint8_t> quantizedSpectrumMaxBits;
    jarray2_ptr<uint8_t> quantizedSpectrumBits;
    jarray2_ptr<int8_t> quantizedSpectrumValue;
    jarray2_ptr<uint8_t> quantizeSpectrumBits;
    jarray2_ptr<uint8_t> quantizeSpectrumValue;
    array_ptr<double> mdctWindow;
    array_ptr<uint8_t> athCurve;

} _criTables;

template<typename T, typename U = typename std::enable_if<std::is_integral<T>::value || std::is_floating_point<T>::value, T>::type>
array_ptr<U> CreateArrayOnWrapper(const ArrayUnpacker::ArrayWrapper<> &wrapper) {
    ArrayUnpacker::ArrayWrapper<U> w(wrapper);
    return make_array_dynamic<U>(w.getTypedPointer(), w.getLength(), true, true);
}

template<typename T, typename U = typename std::enable_if<std::is_integral<T>::value || std::is_floating_point<T>::value, T>::type>
jarray2_ptr<U> CreateJArray2OnWrapper(const ArrayUnpacker::ArrayWrapper<> &wrapper) {
    const auto dim1 = wrapper.getLength();

    const auto arr = make_jagged_array_2_dynamic<U>(dim1);
    const auto ptr = reinterpret_cast<const ArrayUnpacker::ArrayWrapper<U> *>(wrapper.getPointer());

    for (auto i = 0; i < dim1; i += 1) {
        auto &w = ptr[i];
        auto a = make_array_dynamic<U>(w.getTypedPointer(), w.getLength(), true, true);
        (*arr)[i] = a;
    }

    return arr;
}

static inline void GenerateCriHcaGlobalTables() noexcept {
    _criTables.dequantizerScalingTable = generateArray<double, 64>(DequantizerScalingFunction);
    _criTables.quantizerStepSize = generateArray<double, 16>(QuantizerStepSizeFunction);
    _criTables.quantizerDeadZone = generateArray<double, 16>(QuantizerDeadZoneFunction);
    _criTables.quantizerScalingTable = generateArray<double, 64>([](int32_t x) {
        return 1 / DequantizerScalingFunction(x);
    });
    _criTables.quantizerInverseStepSize = generateArray<double, 16>(QuantizerInverseStepSizeFunction);
    _criTables.resolutionMaxValues = generateArray<int32_t, 16>(ResolutionMaxValueFunction);
    _criTables.intensityRatioTable = generateArray<double, 15>(IntensityRatioFunction);
    _criTables.intensityRatioBoundsTable = generateArray<double, 14>(IntensityRatioBoundsFunction);
    _criTables.scaleConversionTable = generateArray<double, 128>(ScaleConversionTableFunction);

    const auto arrayDefs = ArrayUnpacker::unpackArray(PackedTables, sizeof(PackedTables));

    assert(arrayDefs->size() == 10);

    ArrayUnpacker::TypeIndex typeIndex;
    ArrayUnpacker::ArrayWrapper<> wrapper;
    tie(typeIndex, wrapper) = (*arrayDefs)[0];
    assert(typeIndex == ArrayUnpacker::TypeIndex::UInt8);
    _criTables.quantizeSpectrumBits = CreateJArray2OnWrapper<uint8_t>(wrapper);
    tie(typeIndex, wrapper) = (*arrayDefs)[1];
    assert(typeIndex == ArrayUnpacker::TypeIndex::UInt8);
    _criTables.quantizeSpectrumValue = CreateJArray2OnWrapper<uint8_t>(wrapper);
    tie(typeIndex, wrapper) = (*arrayDefs)[2];
    assert(typeIndex == ArrayUnpacker::TypeIndex::UInt8);
    _criTables.quantizedSpectrumBits = CreateJArray2OnWrapper<uint8_t>(wrapper);
    tie(typeIndex, wrapper) = (*arrayDefs)[3];
    assert(typeIndex == ArrayUnpacker::TypeIndex::UInt8);
    _criTables.quantizedSpectrumMaxBits = CreateArrayOnWrapper<uint8_t>(wrapper);
    tie(typeIndex, wrapper) = (*arrayDefs)[4];
    assert(typeIndex == ArrayUnpacker::TypeIndex::Int8);
    _criTables.quantizedSpectrumValue = CreateJArray2OnWrapper<int8_t>(wrapper);
    tie(typeIndex, wrapper) = (*arrayDefs)[5];
    assert(typeIndex == ArrayUnpacker::TypeIndex::UInt8);
    _criTables.scaleToResolutionCurve = CreateArrayOnWrapper<uint8_t>(wrapper);
    tie(typeIndex, wrapper) = (*arrayDefs)[6];
    assert(typeIndex == ArrayUnpacker::TypeIndex::UInt8);
    _criTables.athCurve = CreateArrayOnWrapper<uint8_t>(wrapper);
    tie(typeIndex, wrapper) = (*arrayDefs)[7];
    assert(typeIndex == ArrayUnpacker::TypeIndex::Double);
    _criTables.mdctWindow = CreateArrayOnWrapper<double>(wrapper);
    tie(typeIndex, wrapper) = (*arrayDefs)[8];
    assert(typeIndex == ArrayUnpacker::TypeIndex::UInt8);
    _criTables.defaultChannelMapping = CreateArrayOnWrapper<uint8_t>(wrapper);
    tie(typeIndex, wrapper) = (*arrayDefs)[9];
    assert(typeIndex == ArrayUnpacker::TypeIndex::UInt8);
    _criTables.validChannelMappings = CreateJArray2OnWrapper<uint8_t>(wrapper);

    for (const auto &tuple : *arrayDefs) {
        tie(typeIndex, wrapper) = tuple;
        ArrayUnpacker::releaseWrappedArray(typeIndex, wrapper);
    }
}

narray_ptr<double, 64> CriHcaTables::getDequantizerScalingTable() {
    return _criTables.dequantizerScalingTable;
}

narray_ptr<double, 16> CriHcaTables::getQuantizerStepSize() {
    return _criTables.quantizerStepSize;
}

narray_ptr<double, 16> CriHcaTables::getQuantizerDeadZone() {
    return _criTables.quantizerDeadZone;
}

narray_ptr<double, 64> CriHcaTables::getQuantizerScalingTable() {
    return _criTables.quantizerScalingTable;
}

narray_ptr<double, 16> CriHcaTables::getQuantizerInverseStepSize() {
    return _criTables.quantizerInverseStepSize;
}

narray_ptr<int32_t, 16> CriHcaTables::getResolutionMaxValues() {
    return _criTables.resolutionMaxValues;
}

narray_ptr<double, 15> CriHcaTables::getIntensityRatioTable() {
    return _criTables.intensityRatioTable;
}

narray_ptr<double, 14> CriHcaTables::getIntensityRatioBoundsTable() {
    return _criTables.intensityRatioBoundsTable;
}

narray_ptr<double, 128> CriHcaTables::getScaleConversionTable() {
    return _criTables.scaleConversionTable;
}

array_ptr<uint8_t> CriHcaTables::getDefaultChannelMapping() {
    return _criTables.defaultChannelMapping;
}

jarray2_ptr<uint8_t> CriHcaTables::getValidChannelMappings() {
    return _criTables.validChannelMappings;
}

array_ptr<uint8_t> CriHcaTables::getScaleToResolutionCurve() {
    return _criTables.scaleToResolutionCurve;
}

array_ptr<uint8_t> CriHcaTables::getQuantizedSpectrumMaxBits() {
    return _criTables.quantizedSpectrumMaxBits;
}

jarray2_ptr<uint8_t> CriHcaTables::getQuantizedSpectrumBits() {
    return _criTables.quantizedSpectrumBits;
}

jarray2_ptr<int8_t> CriHcaTables::getQuantizedSpectrumValue() {
    return _criTables.quantizedSpectrumValue;
}

jarray2_ptr<uint8_t> CriHcaTables::getQuantizeSpectrumBits() {
    return _criTables.quantizeSpectrumBits;
}

jarray2_ptr<uint8_t> CriHcaTables::getQuantizeSpectrumValue() {
    return _criTables.quantizeSpectrumValue;
}

array_ptr<double> CriHcaTables::getMdctWindow() {
    return _criTables.mdctWindow;
}

array_ptr<uint8_t> CriHcaTables::getAthCurve() {
    return _criTables.athCurve;
}
